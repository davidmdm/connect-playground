package main

import (
	"context"
	"crypto/rand"
	"crypto/rsa"
	"net/http"

	"github.com/circleci/backplane-go/environment"
	"github.com/circleci/samwise/observability"
	"github.com/gin-gonic/gin"
	"github.com/lestrrat-go/jwx/v2/jwk"
	"golang.org/x/net/http2"
	"golang.org/x/net/http2/h2c"

	// generated by protoc-gen-go
	"github.com/davidmdm/connect-playground/internal/proto/signer/v1/signerv1connect"
	"github.com/davidmdm/connect-playground/internal/signer"
)

func main() {
	ctx, teardown := observability.MustReportingContext(context.Background(), environment.FromOS())
	defer teardown(ctx)

	privKey, pubKey := MustGenerateKeyPair()

	set := jwk.NewSet()
	set.AddKey(pubKey)

	handler := ServerHandler(ctx, signer.MakeService(privKey), set)

	http.ListenAndServe(":8080", handler)
}

func ServerHandler(ctx context.Context, svc signer.Service, jwkSet jwk.Set) http.Handler {
	gin.SetMode(gin.ReleaseMode)
	engine := gin.New()

	engine.Use(observability.Middlewares(observability.FromContext(ctx))...)

	engine.Any(GinAdaptor(signerv1connect.NewSignerServiceHandler(svc)))

	engine.GET("/jwks.json", func(ctx *gin.Context) { ctx.JSON(200, jwkSet) })

	return h2c.NewHandler(engine, new(http2.Server))
}

func GinAdaptor(path string, h http.Handler) (string, gin.HandlerFunc) {
	return path + "*rpc", func(c *gin.Context) {
		c.Request = c.Request.WithContext(
			observability.WithFields(
				c.Request.Context(),
				observability.Fields{"rpc": c.Param("rpc")},
			),
		)

		h.ServeHTTP(c.Writer, c.Request)
	}
}

func MustGenerateKeyPair() (priv, pub jwk.Key) {
	rsaKey, err := rsa.GenerateKey(rand.Reader, 2048)
	if err != nil {
		panic(err)
	}

	priv, err = jwk.FromRaw(rsaKey)
	if err != nil {
		panic(err)
	}
	priv.Set("alg", "RS256")
	priv.Set("kid", "test")

	pub, err = priv.PublicKey()
	if err != nil {
		panic(err)
	}
	return
}
